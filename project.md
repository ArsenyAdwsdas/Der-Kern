# Таблица контента
0. [Чиво](#Чиво)
1. [Введение](#Введение)
-  [Компиляции и интерпретации](##Компиляции/интерпретации)
2. [Проблема+актуальность](#Проблема+актуальность)
- [Недоверие](##Недоверие)
3. [Решение](#Решение)
- [История](##История)

# Чиво
Der Kern было выбрано мной как проект по причине "мне нужно все равно делать проект для коледжа".
Тема="основа JIT компилируемых языков"
НазваниеМоейОсновы="Der Kern"


# Введение
JIT компиляция - компиляция непосредственно во время работы программы, а не до выполнения как в случае большинства компилируемых языков
Основу делаю потому, что я планирую делать JIT компилируемые языки в своих целях
## Компиляции/интерпретации
При обычной компиляции код компилируется и результат распространяется, при JIT компиляции распространяется компилируемое.
Если распространять результат компиляции, то могут возникнуть проблемы из-за различий процессоров и операционных систем, в результате которых выполнение будет не очень возможным без виртуальных машин. При распространении компилируемого обычно требуется компилировать для запуска, но проблем с выполнением не будет пока имеется то, что будет компилировать, также можно ускорить повторные запуски до очень схожей с обычной компиляцией скорости. Существуют также интерпретаторы языков, которые могут выполнять код без компиляции, однако у них встречаемы свои проблемы(часто со скоростью и оперативной памятью), которые могут сделать использование языков без компиляции очень нежелательным.
Результат "НЕ JIT компиляции" обычно сохраняется в файлы, ну и сама такая компиляция обычно требует файлы, содержащие компилируемый кода...
Однако во многих случаях именно это с высокой вероятностью приводит к проблемам, ведь обычно не получится нормально запустить такую программу на другой операционной системе.
- JIT компиляцию же еще можно подготовить для улучшений в определенных случаях, например иногда можно заменить части более малыми и более быстрыми.
- JIT компиляцию можно сделать заменой хорошей смеси интерпретатора и компилятора из-за скорости и потенциальной возможности использовать и создавать новое как в интерпретируемых языках, например в C# можно использовать и создавать новые типы и функции во время работы программы, хотя именно создавать может быть проблематично...

# Проблема+актуальность
Создавать игры сложнее Mario в интерпретируемых языках может быть проблемно в высокой степени, например в моей старой уже попытке сделать игру хватало 100 снарядов с одним легко изменяемым поведением для уравнивания количества кадров в секунду с нулем.
- JIT компиляция же может позволять использовать компилируемые языки как интерпретируемые значительно улучшая ситуацию со скоростью.
- JIT компиляция также позволяет делать менее ограниченные игры, например битва магов с заклинаниями(кодами) написанными на JIT компилируемом языке игроками во время матча сможет допустить значительные количества снарядов с любыми поведениями из JIT компилированных заклинаний(кодов).
## Недоверие
Существуют уже различные(LLVM, GNU Lightning, libJIT, RPython) библиотеки подходящие для создания JIT компилируемых языков, однако я мало им доверяю по личным причинам и из-за этого я предпочту сделать свою основу вместо изучения как они сделаны(мне уже хватило очень любимых судя по всему другими токенизеров и всего такого).
- RPython не доверяю больше всего за все эти мягко говоря не очень уважаемые скорости в "Python". JIT я такое называть отказываюсь.
Поэтому моей целью в этот раз является создание своей основы для JIT компилируемых языков.

# Решение
Без JIT компиляции минимум 2 из моих идей и так не очень здравомыслящего о собственных желаниях меня приведут только к ужасным в не очень хорошую сторону результатам говоря о скорости и, скорее всего, переписи кода для JIT компиляции.
## История
Причины:
- Решение делать свои языки у меня произошло еще при попытках сделать свою игру, ведь мне хотелось там сделать заклинания, однако делаемое мной было слишком ужасным.
- - Количество кадров в секунду стремилось к нулю при каждых моих попытках создать простой снаряд 100 раз...
- Были попытки сделать свой ии... 
- - Адекватного и подходящего языка без мутирующих чисел и нападений на оперативную память на это все не хватало.
Пытался, не получилось. Пытался, не получилось... Шло время, меня много раз затомил уже C++ со своими и моими проблемами...
В итоге я в какой-то момент решил сделать свой язык с желаемым синтаксисом определенным образом, заново и заново вновь повторял попытки продумать синтаксис...
И вот я тут... С желанием использовать JIT компиляцию в чистых и не очень чистых целях вместо сражений со скоростями интерпретаторов.
- Что изменилось кроме моего умения страдать с логикой? Кажется ничего другого влияющего на исход не изменилось за эти 2 года...

# Этапы
1. Написание простой логики для работы простых команд(pong, "jmp+2", file) и комментариев, также создание простых динамическим масивов(для инструкций, байтиков x86 инструкций и тд) и поддержки инструкций с компиляцией и "выполнением"(без компиляции)
- Выполнено
- "jmp+2" было отдельной командой "пропустить следующую строку" на тот момент тк я не очень в то время хотел это делать правильно(слишком много думать надо было бы)
2. Написание вспомогательных типов/функций, удобных функций для получения различных значений(string("вот так в ковычках", с поддержкой "\0\n\r\t\b" и тд), числа, имена(например переменных)) из текста
- Выполнено
- Encods/UTF8 осталось как кусок на будующее, хоть он можется остатся ненужен тк с UTF8 можно работать в некоторой степени как с просто ASCII
- Кажется стоило бы упомянуть подготовку к грядущему аду с хорошим хранением инструкций и типов
3. Написание полноценной логики: типов, "компоновки математики" и компиляции с "адекватными" оптимизациями
- В процессе
- Слишком много оптимизаций делать и при этом большая часть не очень разумной кажется... Казалось бы разумной если бы не указатели, масивы, функции и тд...
- - Существует тип "int" -> существует "int*" -> существует "int\**\*\*\*\*\*\*\*\*\*\*\*" +столько же типов сколько звездочек видишь(привет ANSI C со своей гарантированной поддержкой 12 звездочек...)
- - ну пусть масивы будут отдельными полноценными типами... "int[1], int[2], int[3], int[4], int[5], int[6], ..., int[n]"... Хватает оперативной памяти на компиляцию? Ну да... Ну сейчас быстренько поправим используя "n" масивов где n=99999...
- - А функции?..
- Под "компоновкой математики" имею ввиду поддержку операций "как в любых адекватных языках программирования"... если считать таковым C++...
- - "1+51", "func(12,35)", "-a", "a=b", "a(b()-1,c(*d(1)))"